#!/bin/sh

true /*
# Shell script will interpret above as a command and execute everything after
# it, while JavaScript will interpret this as beginning of a comment and skip
# shell script contents.
#
# As shell script parses lines only when they are needed, nothing after exit 1
# can possibly cause a syntax error.

if nodepath="$(command -v node || command -v nodejs)"; then
	exec "$nodepath" "$0" "$@"
fi
echo "We require Node.js version 8 or later; Node.js not found"
exit 1
*/;

const child_process = require('child_process');
const fs = require('fs');
const path = require('path');

// Make sure we're Node 8+

try {
	eval('{ let a = async () => {}; }');
} catch (e) {
	console.log("We require Node.js version 8 or later; you're using " + process.version);
	process.exit(1);
}

// Make sure config.js exists. If not, copy it over synchronously from
// config-example.js, since it's needed before we can start the server

try {
	require.resolve('./config/config');
} catch (e) {
	if (e.code !== 'MODULE_NOT_FOUND' && e.code !== 'ENOENT') throw e; // should never happen

	console.log('config.js does not exist. Creating one with default settings...');
	fs.writeFileSync(
		path.resolve(__dirname, 'config/config.js'),
		fs.readFileSync(path.resolve(__dirname, 'config/config-example.js'))
	);
}

const Config = require('./config/config');

/**
 * Helper for installing missing dependencies.
 * @param {string} dependency - Package name.
 * @param {string?} flags - Any flags to be passed to npm on install.
 * @param {string?} setting - Key for Config setting of optional dependency. Null if mandatory.
 * @return {boolean}
 */
function installDeps(dependency, flags, setting) {
	if (setting && (!Config.hasOwnProperty(setting) || !Config[setting])) return false;

	try {
		require.resolve(dependency);
	} catch (e) {
		if (e.code !== 'MODULE_NOT_FOUND' && e.code !== 'ENOENT') {
			console.error('An unknown error occurred when attempting to install ' + dependency + '.');
			process.exit(-1);
		}

		let prettyDependency = (setting === null) ? 'dependencies' : 'optional dependency ' + dependency;
		console.log('Installing ' + prettyDependency + '...');
		try {
			let statement = 'npm install ' + flags;
			if (setting !== null) statement += ' ' + dependency;
			require('child_process').execSync(statement, {stdio: 'inherit'});
		} catch (e) {
			let buf = 'Something went wrong while installing ' + prettyDependency + '. ';
			buf += 'Please run "npm install ' + flags + prettyDependency + '" manually before attempting to launch the server' + (setting ? '.' : ', or disable Config.' + setting + '.');
			console.error(buf);
			process.exit(-1);
		}
	}

	return true;
}

// Make sure our dependencies are available, and install them if they
// aren't. If config has settings requiring optional dependencies enabled,
// confirm those are installed as well.

const nodeDeps = [
	['sockjs', '--production', null],
	['nodemailer', '--no-save', 'crashguardemail'],
	['ofe', '--no-save', 'ofe']
];
nodeDeps.forEach(dep => installDeps(...dep));

if (!process.argv[2] || /^[0-9]+$/.test(process.argv[2])) {
	// Start the server. We manually load app.js so it can be configured to run as
	// the main module, rather than this file being considered the main module.
	// This ensures any dependencies that were just installed can be found when
	// running on Windows and avoids any other potential side effects of the main
	// module not being app.js like it is assumed to be.
	//
	// The port the server should host on can be passed using the second argument
	// when launching with this file the same way app.js normally allows, e.g. to
	// host on port 9000:
	// $ ./pokemon-showdown 9000

	require('module')._load('./app', module, true);
} else switch (process.argv[2]) {
	case 'generate-team':
		const Dex = require('./sim/dex');
		global.toId = Dex.getId;
		const seed = process.argv[4] ? process.argv[4].split(',').map(Number) : undefined;
		console.log(Dex.packTeam(Dex.generateTeam(process.argv[3], seed)));
		break;
	default:
		console.error('Unrecognized command: ' + process.argv[2]);
		process.exit(1);
}
